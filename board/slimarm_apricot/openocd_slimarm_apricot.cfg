# SlimARM Classic Apricot openocd TCL configuration

#### This is the openocd configuration file (TCL) for
#### SlimARM Apricot
#### The followng configuration will set
#### the system to clock 400MHz, initializing DDR2 at 266MHz, probing
#### NAND Part.No.
#### Note:
#### 1. Modify the setting in "Set JTAG adapter" to use your
#### own JTAG debugger.
####
#### Author: jlywxy(jlywxy@outlook.com, github.com/jlywxy)

# Revision:
# * The DDR2 Initialization Part in this File is Completed and Tested OK @ 2023.6.2

## Enable remote debug(especially for IAR inside VM commmunicating to openocd)
bindto 0.0.0.0
## Set JTAG interface adapter
###################################################

source [find /Users/jlywxy/slimicd-jtag.cfg]

###################################################
if { [info exists CHIPNAME] } {
   set _CHIPNAME $CHIPNAME
} else {
   set _CHIPNAME s3c2416
}

if { [info exists ENDIAN] } {
   set _ENDIAN $ENDIAN
} else {
   set _ENDIAN little
}

set CPUTAPID 0x07926f0f
if { [info exists CPUTAPID] } {
   set _CPUTAPID $CPUTAPID
} else {
   set _CPUTAPID 0xffffffff
}

#reset_config srst_only

jtag newtap $_CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id $_CPUTAPID

set _TARGETNAME $_CHIPNAME.cpu
target create $_TARGETNAME arm926ejs -endian $_ENDIAN -chain-position $_TARGETNAME

$_TARGETNAME configure -work-area-phys 0x30000000 -work-area-size 0x10000 -work-area-backup 0

arm7_9 fast_memory_access enable
#arm7_9 dcc_downloads enable

# config nand device
nand device 0 s3c2412 s3c2416.cpu
init
halt

# bit operon for certain register/data
proc set_reg_bit { REG POS MASK VALUE } {
   set BIT_CLEARED_DATA [ expr { ( [read_memory $REG 32 1] | ( $MASK << $POS)) &~ ( $MASK << $POS ) } ]
   mww $REG [ expr { $BIT_CLEARED_DATA | ( ( $VALUE & $MASK ) << $POS ) } ]
}
proc get_reg_bit { REG POS MASK } {
    return [ expr { ( [read_memory $REG 32 1] >> $POS ) & $MASK } ]
}

proc board_init { } {
   echo ""
   echo "------------------- SlimARM ---------------------"
   echo "SlimARM Code: Apricot (SoC: Samsung S3C2416X)"
   ## Check core halt-able
   if { [[target current] curstate] != "halted" } {
      echo "-> \[error\] core not halt-able. check if soldering/connection dependable or chip damaged.\n"
      exit
   }
   ## Check connection
   if { [read_memory 0x48000000 8 1] == "0xff" } {
      echo "-> \[error\] board not connected. \n"
      exit
   }
   ## Detect cores
   echo "-> core: [target current] ([[target current] curstate])"

   echo "-> performing board initialization..."
   # disable watchdog
   mww 0x53000000 0
   #get_clock_info
   #MPLLCON: set 533MHz
   #The PLL stability is based on Power supply condition:
   #To run stable, the core voltage must be over 1.1v.
   mww 0x4c000010 [ expr { 
      # sdiv   pdiv     mdiv        onoff
      1 << 0 | 3 << 5 | 400 << 14 | 0 << 24
   } ]
   get_pll_info
   #CLKDIV0: set 266-133-66 MHz
   mww 0x4c000024 [ expr {
      # armdiv: fout/armdiv(2)=266 [0,...,7]
      1 << 9 |
      # prediv: msysclkprediv=fout/prediv(2)=133 [0,1,2,3]
      1 << 4 |
      # hclkdiv: msysclkprediv(400)/hclkdiv(2)=133 [0,1,3]
      # internal DDRCLK = 2x HCLK (266)
      # external SDCK pin = HCLK (133)
      2 << 0 | 
      # pclkdiv: hclk(133)/pclkdiv(2)=66 [0,1]
      1 << 2 | 
      # halfhclk: hclk(133)/halfhclk(2)=66 [0,1]
      1 << 3
   } ]
   get_clock_info
   echo "-> \[info\] board initialization done."
   
   s3c2416_ddr2_init

   #echo "-> [\info\] nand: [nand probe 0]"
   echo ""
   echo "-> use 'telnet localhost 4444' to connect to REPL over telnet."
   echo "-> use 'board_init' in telnet to re-initialize anytime."
   echo "-> use 'get_clock_info' in telnet to check system freq."
   
   echo "------------------------------------------------"
   echo ""
}

proc s3c2416_ddr2_init { } {
   ########## start ddr2 config
   # the board is using hynix h5ps5182gfr-y5c, 512Mb(4-bank), DDR2-533, (5-5-5)
   echo "-> starting DDR2 DRAM initialization"
   echo "-> note: init for DDR2 timing (3-3-3); clock=133MHz/DDR2-266"

   # set 16-bit bus, ddr2 type, cas/ras bits
   mww 0x48000000 [ expr {
      #  buswidth   memtype      addconf     addconf
      0b1 << 0 | 0b001 << 1 | 0b00 << 4 | 0b00 << 6 |
      #  caswidth1             caswidth0
      0b10 << 8 | 0 << 10 | 0b10 << 11 | 0 << 13 |
      #  raswidth1              raswidth0
      0b10 << 14 | 0 << 16 | 0b10 << 17
   } ]

   # set dqsin delay
   mww 0x48000004 [ expr {
      #  INIT                    pwrdn    auto prech
      0b00 << 0 | 0b00 << 2 | 0 << 4 | 0 << 5 |
      #  wbuffer  burststop                   dqsin delay
      0 << 6 | 0 << 7 | 1 << 8 | 1 << 26 | 0b11 << 28
   } ]

   # set timing, using (3-3-3)
   mww 0x48000008 [ expr {
      #  trp         trcd        cas
      0b10 << 0 | 0b10 << 2 | 0b11 << 4 | 0 << 6 |
      #  tarfc          tras
      0b1100 << 16 | 0b1100 << 20
   } ]

   ########## start ddr2 init seq
   # please refer to s3c2416 ddr2 init deq 

   ##### 3. issue pall
   set_reg_bit 0x48000004 0 0b11 0b01

   ##### 4. issue emrs2
   # template for emrs2
   mww 0x4800000c [ expr {
      #  pasr      dcc       srf       ba
      0 << 16 | 0 << 19 | 0 << 23 | 0b10 << 30
   } ]
   set_reg_bit 0x48000004 0 0b11 0b11

   ###### 5. issue emrs3
   # template for emrs3
   mww 0x4800000c [ expr {
      #  ba
      0b11 << 30
   } ]
   set_reg_bit 0x48000004 0 0b11 0b11

   ##### 6. issue emrs1 for dll enable, rdqs disable, dqs disable, odt disable
   # template for emrs1
   mww 0x4800000c [ expr {
      #  dlle      dic       rtt0      rtt1
      0 << 16 | 0 << 17 | 0 << 18 | 0 << 22 |
      #  addlat    ocd       dqs       rdqs
      0 << 19 | 7 << 23 | 1 << 26 | 0 << 27 |
      #  qoff      ba
      0 << 28 | 0b01 << 30
   } ]
   set_reg_bit 0x48000004 0 0b11 0b11

   ##### 7. issue mrs for dllr
   # template for mrs
   mww 0x4800000c [ expr {
      #  cas         dllr     wr       acticepwrdn
      0b11 << 4 | 1 << 8 | 0 << 9 | 0 << 12
   } ]
   set_reg_bit 0x48000004 0 0b11 0b10

   ##### 8. issue pall
   set_reg_bit 0x48000004 0 0b11 0b01

   ##### 9. af twice
   # note: this not implemented in s3c2416 spec,
   # refering to http://news.eeworld.com.cn/mcu/article_2016121232228.html
   mww 0x48000010 0x20

   ##### 10. issue mrs for no dllr
   # template for mrs
   mww 0x4800000c [ expr {
      #  cas         dllr     wr       acticepwrdn
      0b11 << 4 | 0 << 8 | 0 << 9 | 0 << 12
   } ]
   set_reg_bit 0x48000004 0 0b11 0b10

   ##### 11. issue emrs1 for ocd
   # template for emrs1
   mww 0x4800000c [ expr {
      #  dlle      dic       rtt0      rtt1
      0 << 16 | 0 << 17 | 0 << 18 | 0 << 22 |
      #  addlat    ocd       dqs       rdqs
      0 << 19 | 0 << 23 | 1 << 26 | 0 << 27 |
      #  qoff      ba
      0 << 28 | 0b01 << 30
   } ]
   set_reg_bit 0x48000004 0 0b11 0b11

   ##### 12. normal operation
   set_reg_bit 0x48000004 0 0b11 0b00

   # set refresh cycle: 7.8ns
   mww 0x48000010 0x040f

   # test dram write
   echo "-> \[info\] test DDR2 DRAM write at 0x30000000"
   mww 0x30000000 0x12345678
   mww 0x30000004 0x87654321
   mww 0x30000008 0x10101010
   mww 0x3000000c 0x20202020
   if { [ expr {
      [read_memory 0x30000000 32 1] == 0x12345678 &&
      [read_memory 0x30000004 32 1] == 0x87654321 &&
      [read_memory 0x30000008 32 1] == 0x10101010 &&
      [read_memory 0x3000000c 32 1] == 0x20202020
   } ] == 1} {
      echo "-> \[info\] DDR2 DRAM read/write ok"
   } else {
      echo "-> \[error\] DDR2 DRAM read/write failed"
      echo "-> test DDR2 DRAM write: dump: \n(16-bit) [read_memory 0x30000000 16 8]\n(32-bit) [read_memory 0x30000000 32 4]"
   }

}

proc get_pll_info { } {
   global SDIV
   global PDIV
   global MDIV
   global PLL_FOUT

   set SDIV [ get_reg_bit 0x4c000010 0 0b111 ]
   set PDIV [ get_reg_bit 0x4c000010 5 0b111111 ]
   set MDIV [ get_reg_bit 0x4c000010 14 0b1111111111 ]
   set PLL_FOUT [ expr { (12*$MDIV)/(($PDIV* (2**$SDIV))) } ]
   echo "-> \[info\] PLL running at $PLL_FOUT MHz"
}
proc get_clock_info { } {
   global SDIV
   global PDIV
   global MDIV
   global PLL_FOUT

   set ARMDIV [ get_reg_bit 0x4c000024 9 0b111 ]
   set PREDIV [ get_reg_bit 0x4c000024 4 0b11 ]
   set HALKHCLK [ get_reg_bit 0x4c000024 3 1 ]
   set PCLKDIV [ get_reg_bit 0x40000024 2 1 ]
   set HCLKDIV [ get_reg_bit 0x4c000024 0 0b11 ]

   
   set ARMCLK [ expr { $PLL_FOUT/($ARMDIV+1) } ]
   set MSYSCLKPREDIV [ expr { $PLL_FOUT / ($PREDIV+1) } ]
   set HCLK [ expr { $MSYSCLKPREDIV / ($HCLKDIV+1) } ]
   set PCLK [ expr { $HCLK / ($PCLKDIV+1)}]
   
   echo "-> \[info\] Generated clocks: ARMCLK=$ARMCLK MHz, HCLK=$HCLK MHz, PCLK=$PCLK MHz"
   
}
board_init
# SlimARM Classic Carambola openocd configuration

#### This is the openocd configuration file for 
#### SlimARM Classic board (SlimARM Carambola)
#### The followng configuration will set
#### the system to clock 400MHz, initializing DDR, probing
#### NAND Part.No.
#### Note: 
#### 1. Modify the setting in "Set JTAG adapter" to use your
#### own JTAG debugger.
####
#### Author: jlywxy(jlywxy@outlook.com, github.com/jlywxy)

## Enable remote debug(especially for IAR inside VM commmunicating to openocd)
bindto 0.0.0.0
## Set JTAG interface adapter
###################################################
source [find tools/memtest.tcl]
source [find /Users/jlywxy/slimicd-jtag.cfg]

###################################################
global _DEBUG 1

if { [info exists CHIPNAME] } {
	set AT91_CHIPNAME $CHIPNAME
} else {
	set AT91_CHIPNAME at91sam9g25
}
source [find target/at91sam9.cfg]
$_TARGETNAME configure -work-area-phys 0x00300000 -work-area-size 0x00100000 -work-area-backup 1
reset_config trst_and_srst

init

proc board_init { } {

    

    halt
    echo ""
    echo "----------------SlimARM Classic------------------"
	echo "SlimARM Code: Carambola (SoC: Atmel AT91SAM9G25)"

	## Check core halt-able
    if { [[target current] curstate] != "halted" } {
        echo "-> \[error\] core not halt-able. check if soldering/connection dependable or chip damaged.\n"
        exit
    }
    ## Check connection
    if { [read_memory 0xfffff400 8 1] == "0xff" } {
        echo "-> \[error\] board not connected. \n"
        exit
    }
    ## Detect cores
    echo "-> core: [target current] ([[target current] curstate])"
    
    ##########################################################
    # Disable Watchdog
    #mww 0xfffffd44 0x00008000
    adapter speed 29000
    echo "-> \[info\] board initialization using AT91Bootstrap..."

	echo "-> \[info\] board initialization done."
    echo ""
    echo "-> use 'telnet localhost 4444' to connect to REPL over telnet."
    echo "-> use 'board_init' in telnet to re-initialize anytime."

    echo "------------------------------------------------"
    echo ""
}

proc dramtest { } {
    mww 0x20000000 0x12345678
   mww 0x20000004 0x87654321
   mww 0x20000008 0x10101010
   mww 0x2000000c 0x20202020
   if { [ expr {
      [read_memory 0x20000000 32 1] == 0x12345678 &&
      [read_memory 0x20000004 32 1] == 0x87654321 &&
      [read_memory 0x20000008 32 1] == 0x10101010 &&
      [read_memory 0x2000000c 32 1] == 0x20202020
   } ] == 1} {
      echo "-> \[info\] DDR2 DRAM read/write ok"
   } else {
      echo "-> \[error\] DDR2 DRAM read/write failed"
      echo "-> test DDR2 DRAM write: dump: \n(16-bit) [read_memory 0x20000000 16 8]\n(32-bit) [read_memory 0x20000000 32 4]"
   }
}

proc bootstrap { } {
    load_image /Users/jlywxy/base/project/hardware/slimarm/board/slimarm_carambola/test-firmwares/at91bootstrap-9g25-sram.bin 0x00300000
    verify_image /Users/jlywxy/base/project/hardware/slimarm/board/slimarm_carambola/test-firmwares/at91bootstrap-9g25-sram.bin 0x00300000
    resume 0x00300000
    sleep 1000
    halt

    getclock
    dramtest

    load_image /Users/jlywxy/base/project/hardware/slimarm/test-firmwares/ramvapor/code/ramvapor_carambola.elf
    verify_image /Users/jlywxy/base/project/hardware/slimarm/test-firmwares/ramvapor/code/ramvapor_carambola.elf
    resume 0x00300000
}

proc getclock { } {
    # set_reg_bit 0xfffffc28 16 0xff 0xc7
    # set_reg_bit 0xfffffc28 8 0b111111 0x3f
    # set_reg_bit 0xfffffc28 0 0xff 3
    # mww 0xfffffc30 [ expr { 2<<0 | 1<<4 | 3<<8 }]
    # #mww 0xfffffc30 0x00001302

    # mww 0xffffdf20 [expr {1 << 1|0<<8|0<<9}]
    # mww 0xffffe820 [expr {4 << 0 | 1 << 4}]

    # mww 0xFFFFDF20 0x0102000A

    
    echo "-> \[info\] CKGR_MCFR@0xfffffc24: "
    set CKGR_MCFR [read_memory 0xfffffc24 32 1]
    set CLOCK_MAINF [get_bit $CKGR_MCFR 0 0xffff]
    set MAIN_CLOCK [ expr { $CLOCK_MAINF * 32 / 16 /1000 } ]
    echo "\n\t*Main Clock Calculated: $MAIN_CLOCK MHz\n"

    echo "-> \[info\] CKGR_PLLAR@0xfffffc28: "
    set CKGR_PLLAR [read_memory 0xfffffc28 32 1]
    set DIVA [read_memory 0xfffffc28 8 1]
    echo "\tDIVA: $DIVA"
    set PLLA_MULA [get_bit $CKGR_PLLAR 16 0xff]
    echo "\n\t*PLLA Calculated: [ expr { $MAIN_CLOCK / $DIVA * ( $PLLA_MULA + 1) } ] MHz\n"

    echo "-> \[info\] CKGR_MCKR@0xfffffc30: "
    set CKGR_MCKR [read_memory 0xfffffc30 32 1]
    echo "\tCSS:[get_bit $CKGR_MCKR 0 0b11]\t0:SLOW_CLK,1:MAIN_CLK,2:PLLA_CLK,3:UPLL_CLK"
    echo "\tPRES:[get_bit $CKGR_MCKR 4 0b11]\t0:CLOCK,1:CLOCK_DIV2,2:CLOCK_DIV4,..."
    echo "\tMDIV:[get_bit $CKGR_MCKR 8 0b11]\t0:MCK=Pre,1:MCK=Pre/2,2:MCK=Pre/4,3:MCK=Pre/3"
}
########################################
proc get_bit { DATA POS MASK } {
    return [ expr { ( $DATA >> $POS ) & $MASK } ]
}
proc clear_bit { DATA POS MASK } {
    return [ expr { ( $DATA | ( $MASK << $POS)) &~ ( $MASK << $POS ) } ]
}
proc set_bit { DATA POS MASK VALUE } {
    return [ expr { [clear_bit $DATA $POS $MASK] | (( $VALUE & $MASK ) << $POS) } ]
}
proc set_reg_bit { REG POS MASK VALUE } {
    set BIT_CLEARED_DATA [ expr { ( [read_memory $REG 32 1] | ( $MASK << $POS)) &~ ( $MASK << $POS ) } ]
    mww $REG [ expr { $BIT_CLEARED_DATA | ( ( $VALUE & $MASK ) << $POS ) } ]
}

board_init
# SlimARM Classic Carambola openocd configuration

#### This is the openocd configuration file for 
#### SlimARM Classic board (SlimARM Carambola)
#### The followng configuration will set
#### the system to clock 400MHz, initializing DDR, probing
#### NAND Part.No.
#### Note: 
#### 1. Modify the setting in "Set JTAG adapter" to use your
#### own JTAG debugger.
####
#### Author: jlywxy(jlywxy@outlook.com, github.com/jlywxy)

## Enable remote debug(especially for IAR inside VM commmunicating to openocd)
bindto 0.0.0.0
## Set JTAG interface adapter
###################################################

source [find interface/altera-usb-blaster.cfg]
set _DEBUG 0
###################################################
if { [info exists CHIPNAME] } {
	set AT91_CHIPNAME $CHIPNAME
} else {
	set AT91_CHIPNAME at91sam9g25
}
source [find target/at91sam9.cfg]
$_TARGETNAME configure -work-area-phys 0x00300000 -work-area-size 0x00100000 -work-area-backup 1
arm7_9 dcc_downloads enable
arm7_9 fast_memory_access enable
reset_config srst_only

init

proc issue_ddr2_command { MODE ADDRESS } {
    # MODE: 0:NORMAL,1:NOP,2:PRECHARGE,3:MRS,
    #       4:AUTOFRESH,5:EMRS,6:DOWN
    if { $MODE == 0 } { echo "-> \[info\]Issue NORMAL DDR COMMAND" }
    if { $MODE == 1 } { echo "-> \[info\]Issue NOP DDR COMMAND" }
    if { $MODE == 2 } { echo "-> \[info\]Issue PRECHARGE DDR COMMAND" }
    if { $MODE == 3 } { echo "-> \[info\]Issue MRS DDR COMMAND" }
    if { $MODE == 4 } { echo "-> \[info\]Issue AUTOFRESH DDR COMMAND" }
    if { $MODE == 5 } { echo "-> \[info\]Issue EMRS DDR COMMAND" }
    if { $MODE == 6 } { echo "-> \[info\]Issue POWERDOWN DDR COMMAND" }
    mww 0xffffe800 $MODE
    mww $ADDRESS 0
}
proc get_bit { DATA POS MASK } {
    return [ expr { ( $DATA >> $POS ) & $MASK } ]
}

proc board_init { _DEBUG } {
    halt
    echo ""
    echo "----------------SlimARM Classic------------------"
	echo "SlimARM Code: Carambola (SoC: Atmel AT91SAM9G25)"

	## Check core halt-able
    if { [[target current] curstate] != "halted" } {
        echo "-> \[error\] core not halt-able. check if soldering/connection dependable or chip damaged.\n"
        exit
    }
    ## Check connection
    if { [read_memory 0xfffff400 8 1] == "0xff" } {
        echo "-> \[error\] board not connected. \n"
        exit
    }
    ## Detect cores
    echo "-> core: [target current] ([[target current] curstate])"
    echo "-> performing board initialization..."

    ##########################################################
    # Disable Watchdog
    mww 0xfffffd44 0x00008000

    echo "-> \[info\] Checking Clock Info"
    echo "-> \[info\] PMC_SCSR@0xfffffc08: "
    set PMC_SCSR [read_memory 0xfffffc08 32 1]
    echo "\t*COMMENT: 1 - enabled; 0 - disabled"
    echo "\tDDRCK:[get_bit $PMC_SCSR 2 1]"
    echo "\tSMDCK:[get_bit $PMC_SCSR 4 1]"
    echo "\tUHP:[get_bit $PMC_SCSR 6 1]"
    echo "\tUDP:[get_bit $PMC_SCSR 7 1]"
    echo "\tPCK0:[get_bit $PMC_SCSR 8 1]"
    echo "\tPCK1:[get_bit $PMC_SCSR 9 1]"

    echo "-> \[info\] CKGR_MOR@0xfffffc20: "
    set CKGR_MOR [read_memory 0xfffffc20 32 1]
    echo "\tMOSCXTEN:[get_bit $CKGR_MOR 0 1]\t12-16XTAL: enable/disable"
    echo "\tMOSCXTBY:[get_bit $CKGR_MOR 1 1]\t12-16XTAL: Bypass"
    echo "\tMOSCRCEN:[get_bit $CKGR_MOR 3 1]\t12RC: enable/disable"
    echo "\tMOSCSEL:[get_bit $CKGR_MOR 24 1]\t12RC/12-16XTAL: selected"
    
    echo "-> \[info\] CKGR_MCFR@0xfffffc24: "
    set CKGR_MCFR [read_memory 0xfffffc24 32 1]
    set CLOCK_MAINF [get_bit $CKGR_MCFR 0 0xffff]
    echo "\tMAINF:$CLOCK_MAINF - Main Clock Frequency"
    set MAIN_CLOCK [ expr { $CLOCK_MAINF * 32 / 16 /1000 } ]
    echo "\t*Main Clock Calculated: $MAIN_CLOCK MHz"

    echo "-> \[info\] CKGR_PLLAR@0xfffffc28: "
    set CKGR_PLLAR [read_memory 0xfffffc28 32 1]
    echo "\tDIVA:[get_bit $CKGR_PLLAR 0 0b1111111]"
    echo "\tPLLACOUNT:[get_bit $CKGR_PLLAR 8 0b111111]"
    echo "\tOUTA:[get_bit $CKGR_PLLAR 14 0b11]"
    set PLLA_MULA [get_bit $CKGR_PLLAR 16 0xff]
    echo "\tMULA:$PLLA_MULA"
    echo "\t*PLLA Calculated: [ expr { $MAIN_CLOCK * ($PLLA_MULA+1) } ] MHz"

    ####### Setting master clock source to PLLA
    echo "-> \[info\] Setting master clock source to PLLA"
    mww 0xfffffc30 [ expr { 2<<0 | 3<<4 | 3<<8 }]

    echo "-> \[info\] CKGR_MCKR@0xfffffc30: "
    set CKGR_MCKR [read_memory 0xfffffc30 32 1]
    echo "\tCSS:[get_bit $CKGR_MCKR 0 0b11]\t0:SLOW_CLK,1:MAIN_CLK,2:PLLA_CLK,3:UPLL_CLK"
    echo "\tPRES:[get_bit $CKGR_MCKR 4 0b11]\t0:CLOCK,1:CLOCK_DIV2,2:CLOCK_DIV4,..."
    echo "\tMDIV:[get_bit $CKGR_MCKR 8 0b11]\t0:MCK=Pre,1:MCK=Pre/2,2:MCK=Pre/4,3:MCK=Pre/3"
    echo "\tPLLADIV2:[get_bit $CKGR_MCKR 12 1]\t0:NOT_DIV2,1:DIV2"

    echo "-> \[info\] PMC_SR@0xfffffc68: "
    set PMC_SR [read_memory 0xfffffc68 32 1]
    echo "\tMOSCXTS:[get_bit $PMC_SR 0 1]\t12-16XTAL: stablized/not"
    echo "\tLOCKA:[get_bit $PMC_SR 1 1]\tPLLA: locked/not"
    echo "\tMCKRDY:[get_bit $PMC_SR 3 1]\tMaster Clock: ready/not"
    echo "\tLOCKU:[get_bit $PMC_SR 6 1]\tUPLL: ready/not"
    echo "\tOSCSELS:[get_bit $PMC_SR 7 1]\tSlow Clock RC: select/not"
    echo "\tMOSCRCS:[get_bit $PMC_SR 17 1]\t12RC: stablized/not"

    ####### Setting up DDR2
    echo "-> \[info\] Setting up DDR2"

    echo "-> \[info\] CCFG_EBICSA@0xffffdf20: "
    set CCFG_EBICSA [read_memory 0xffffdf20 32 1]
    echo "\tEBI_CS1A:[get_bit $CCFG_EBICSA 1 1]\t1: CS1 to DDR2"
    echo "\tEBI_CS3A:[get_bit $CCFG_EBICSA 3 1]\t1: CS3 to NAND"
    echo "\tEBI_DBPUC:[get_bit $CCFG_EBICSA 8 1]\t1: EBI Data Pull-up: enabled/not"
    echo "\tEBI_DBPDC:[get_bit $CCFG_EBICSA 9 1]\t1: EBI Data Pull-down: enabled/not"
    echo "\tEBI_DRIVE:[get_bit $CCFG_EBICSA 17 1]\t1: EBI Drive: low/high"
    echo "\tDDR_MP_EN:[get_bit $CCFG_EBICSA 25 1]\t1: DDR Multiport: enabled/not"

    echo "-> \[info\] Setting DDR2 Chip Select"
    mww 0xffffdf20 [expr {1 << 1|0<<8|0<<9}]

    echo "-> \[info\] CCFG_EBICSA@0xffffdf20: "
    set CCFG_EBICSA [read_memory 0xffffdf20 32 1]
    echo "\tEBI_CS1A:[get_bit $CCFG_EBICSA 1 1]\t1: CS1 to DDR2"
    echo "\tEBI_CS3A:[get_bit $CCFG_EBICSA 3 1]\t1: CS3 to NAND"
    echo "\tEBI_DBPUC:[get_bit $CCFG_EBICSA 8 1]\t1: EBI Data Pull-up: enabled/not"
    echo "\tEBI_DBPDC:[get_bit $CCFG_EBICSA 9 1]\t1: EBI Data Pull-down: enabled/not"
    echo "\tEBI_DRIVE:[get_bit $CCFG_EBICSA 17 1]\t1: EBI Drive: low/high"
    echo "\tDDR_MP_EN:[get_bit $CCFG_EBICSA 25 1]\t1: DDR Multiport: enabled/not"


    echo "-> \[info\] DDRSDRC_MD@0xffffe820: "
    set DDRSDRC_MD [read_memory 0xffffe820 32 1]
    echo "\tMD:[get_bit $DDRSDRC_MD 0 0b111]\t0:SDR,1:LPSDR,3:LPDDR1,4:DDR2"
    echo "\tDBW:[get_bit $DDRSDRC_MD 4 1]\tBus Width 0:32bit,1:16bit"

    echo "-> \[info\] Setting EBI Memory Device"
    mww 0xffffe820 [expr {4 << 0 | 1 << 4}]

    echo "-> \[info\] DDRSDRC_MD@0xffffe820: "
    set DDRSDRC_MD [read_memory 0xffffe820 32 1]
    echo "\tMD:[get_bit $DDRSDRC_MD 0 0b111]\t0:SDR,1:LPSDR,3:LPDDR1,4:DDR2"
    echo "\tDBW:[get_bit $DDRSDRC_MD 4 1]\tBus Width 0:32bit,1:16bit"

    ####### Setting up DDR2 Config and Timing
    echo "-> \[info\] DDRSDRC_CR@0xffffe808: "
    set DDRSDRC_CR [read_memory 0xffffe808 32 1]
    echo "\tNC:[get_bit $DDRSDRC_CR 0 0b11]\t0:9Col,1:10Col,2:11Col,3:12Col"
    echo "\tNR:[get_bit $DDRSDRC_CR 2 0b11]\t0:11Row,1:12Row,2:13Row,3:14Row"
    echo "\tCAS:[get_bit $DDRSDRC_CR 4 0b111]\t"
    echo "\tDLL:[get_bit $DDRSDRC_CR 7 1]\tDLL reset enable/not"
    echo "\tDIC:[get_bit $DDRSDRC_CR 8 1]\tDriver Impedance 0:normal,1:weak"
    echo "\tDIS_DLL:[get_bit $DDRSDRC_CR 9 1]\tDLL 0:enable,1:disable"
    echo "\tOCD:[get_bit $DDRSDRC_CR 12 0b111]\t0:Exit OCD,1:OCD Cali"
    echo "\tNB:[get_bit $DDRSDRC_CR 20 1]\t0:4 Banks,1:8 Banks"
    echo "\tDECOD:[get_bit $DDRSDRC_CR 22 1]\t0:Sequential,1:Interleaved"

    echo "-> \[info\] Setting DDR2 Config"
    mww 0xffffe808 [ expr { 1<<0 | 2<<2 |  3<<4 | 1<<20} ]

    echo "-> \[info\] DDRSDRC_CR@0xffffe808: "
    set DDRSDRC_CR [read_memory 0xffffe808 32 1]
    echo "\tNC:[get_bit $DDRSDRC_CR 0 0b11]\t0:9Col,1:10Col,2:11Col,3:12Col"
    echo "\tNR:[get_bit $DDRSDRC_CR 2 0b11]\t0:11Row,1:12Row,2:13Row,3:14Row"
    echo "\tCAS:[get_bit $DDRSDRC_CR 4 0b111]\t"
    echo "\tNB:[get_bit $DDRSDRC_CR 20 1]\t0:4 Banks,1:8 Banks"


    echo "-> \[info\] Setting DDR2 Timing"
    # Samsung K4T1G164 Timing Spec
    # tRAS: 45ns(6cycle), tRCD: 15ns(2cycle), tWR: 15ns(2cycle), 
    # tRC: 60ns(8cycle), tRP: 15ns(2cycle), tRRD: 7.5ns(2cycle),
    # tWTR: 7.5ns(2cycle), tMRD: 2cycle
    # tRFC: 127.5ns(17cycle), tXSNR: tRFC+10(18cycle), 
    # tXSRD: 200cycle, tXP: 2cycle
    # tXARD: 2cycle, tXARDS: 7cycle, tRPA: ?(15cycle)
    # tRTP: 7.5ns(2cycle), tFAW: 37.5ns(5cycle)
    mww 0xffffe80c [ expr { 6<<0 | 2<<4 | 2<<8 | 8<<12 | 2<<16 | 2<<20 | 2<<24 | 2<<28 } ]
    mww 0xffffe810 [ expr { 17<<0 | 18<<8 | 200<<16 |  2<<24} ]
    mww 0xffffe814 [ expr { 2<<0 | 7<<4 | 15<<8 | 2<<12 | 3<<16 } ]

    echo "-> \[info\] DDRSDRC_TPR0@0xffffe80c: "
    set DDRSDRC_TPR0 [read_memory 0xffffe80c 32 1]
    echo "\tTRAS: [get_bit $DDRSDRC_TPR0 0 0b1111]"
    echo "\tTRCD: [get_bit $DDRSDRC_TPR0 4 0b1111]"
    echo "\tTWR: [get_bit $DDRSDRC_TPR0 8 0b1111]"
    echo "\tTRC: [get_bit $DDRSDRC_TPR0 12 0b1111]"
    echo "\tTRP: [get_bit $DDRSDRC_TPR0 16 0b1111]"
    echo "\tTRRD: [get_bit $DDRSDRC_TPR0 20 0b1111]"
    echo "\tTWTR: [get_bit $DDRSDRC_TPR0 24 0b111]"
    echo "\tREDUCE_WRRD: [get_bit $DDRSDRC_TPR0 27 1]"
    echo "\tTMRD: [get_bit $DDRSDRC_TPR0 28 0b1111]"

    echo "-> \[info\] DDRSDRC_TPR1@0xffffe810: "
    set DDRSDRC_TPR1 [read_memory 0xffffe810 32 1]
    echo "\tTRFC: [get_bit $DDRSDRC_TPR1 0 0b11111]"
    echo "\tTXSNR: [get_bit $DDRSDRC_TPR1 8 0b11111111]"
    echo "\tTXSRD: [get_bit $DDRSDRC_TPR1 16 0b11111111]"
    echo "\tTXP: [get_bit $DDRSDRC_TPR1 24 0b1111]"

    echo "-> \[info\] DDRSDRC_TPR2@0xffffe814: "
    set DDRSDRC_TPR2 [read_memory 0xffffe814 32 1]
    echo "\tTXARD: [get_bit $DDRSDRC_TPR2 0 0b1111]"
    echo "\tTXARDS: [get_bit $DDRSDRC_TPR2 4 0b1111]"
    echo "\tTRPA: [get_bit $DDRSDRC_TPR2 8 0b1111]"
    echo "\tTRTP: [get_bit $DDRSDRC_TPR2 12 0b111]"
    echo "\tTFAW: [get_bit $DDRSDRC_TPR2 16 0b1111]"

    ####### Start Samsung DDR2 Init Procedure
    # BA0=A24, BA1=A25, BA2=A26
    # MODE: 0:NORMAL,1:NOP,2:PRECHARGE,3:MRS,
    #       4:AUTOFRESH,5:EMRS,6:DOWN
    # 1. Power; 2. Clock


    ###### Setting DDR CKE High
    echo "-> \[info\] Setting DDR2 clock Enabled"
    # PMC_SCDR@0xfffffc00
    #       2: DDRCK(0)
    mww 0xfffffc04 0x0
    # PMC_SCER@0xfffffc00
    #       2: DDRCK(1)
    mww 0xfffffc00 [ expr { [read_memory 0x0xfffffc08 32 1] | 1 << 2} ]

    echo "-> \[info\] PMC_SCSR@0xfffffc08: "
    set PMC_SCSR [read_memory 0xfffffc08 32 1]
    echo "\tDDRCK:[get_bit $PMC_SCSR 2 1]"

    # 3. issue NOP
    issue_ddr2_command 1 0x20000000
    # 4. issue NOP; issue Precharge
    issue_ddr2_command 1 0x20000000
    issue_ddr2_command 2 0x20000000
    # 5. issue EMRS2: BA1=1
    issue_ddr2_command 5 [ expr { 0x20000000 | 1<<(25) } ]
    # 6. issue EMRS3: BA0=1,BA1=1
    issue_ddr2_command 5 [ expr { 0x20000000 | 1<<(24) | 1<<(25) } ]
    # 7. issue EMRS1(Enable DLL): BA0=1
    issue_ddr2_command 5 [ expr { 0x20000000 | 1<<(24) } ]

    # ADD: AT: 9. Enable DLL

    # DLL has enabled(default); enabling DLL reset
    mww 0xffffe808 [ expr { [read_memory 0xffffe808 32 1] | 1<<7} ]

    echo "-> \[info\] DDRSDRC_CR@0xffffe808: "
    set DDRSDRC_CR [read_memory 0xffffe808 32 1]
    echo "\tNC:[get_bit $DDRSDRC_CR 0 0b11]\t0:9Col,1:10Col,2:11Col,3:12Col"
    echo "\tNR:[get_bit $DDRSDRC_CR 2 0b11]\t0:11Row,1:12Row,2:13Row,3:14Row"
    echo "\tCAS:[get_bit $DDRSDRC_CR 4 0b111]\t"
    echo "\tDLL:[get_bit $DDRSDRC_CR 7 1]\tDLL reset enable/not"
    echo "\tDIC:[get_bit $DDRSDRC_CR 8 1]\tDriver Impedance 0:normal,1:weak"
    echo "\tDIS_DLL:[get_bit $DDRSDRC_CR 9 1]\tDLL 0:enable,1:disable"
    echo "\tOCD:[get_bit $DDRSDRC_CR 12 0b111]\t0:Exit OCD,1:OCD Cali"
    echo "\tNB:[get_bit $DDRSDRC_CR 20 1]\t0:4 Banks,1:8 Banks"
    echo "\tDECOD:[get_bit $DDRSDRC_CR 22 1]\t0:Sequential,1:Interleaved"

    # 8. issue MRS(DLL Reset): A8=1
    issue_ddr2_command 3 [ expr { 0x20000000 | 1<<(8+2) } ]
    
    # 9. issue Precharge
    issue_ddr2_command 2 0x20000000
    # 10. issue 2+ Auto-Fresh
    issue_ddr2_command 4 0x20000000
    issue_ddr2_command 4 0x20000000

    # AD: AT: 13. Disable DLL Reset
    mww 0xffffe808 [ expr { [read_memory 0xffffe808 32 1] &~ (1<<7)} ]

    echo "-> \[info\] DDRSDRC_CR@0xffffe808: "
    set DDRSDRC_CR [read_memory 0xffffe808 32 1]
    echo "\tNC:[get_bit $DDRSDRC_CR 0 0b11]\t0:9Col,1:10Col,2:11Col,3:12Col"
    echo "\tNR:[get_bit $DDRSDRC_CR 2 0b11]\t0:11Row,1:12Row,2:13Row,3:14Row"
    echo "\tCAS:[get_bit $DDRSDRC_CR 4 0b111]\t"
    echo "\tDLL:[get_bit $DDRSDRC_CR 7 1]\tDLL reset enable/not"
    echo "\tDIC:[get_bit $DDRSDRC_CR 8 1]\tDriver Impedance 0:normal,1:weak"
    echo "\tDIS_DLL:[get_bit $DDRSDRC_CR 9 1]\tDLL 0:enable,1:disable"
    echo "\tOCD:[get_bit $DDRSDRC_CR 12 0b111]\t0:Exit OCD,1:OCD Cali"
    echo "\tNB:[get_bit $DDRSDRC_CR 20 1]\t0:4 Banks,1:8 Banks"
    echo "\tDECOD:[get_bit $DDRSDRC_CR 22 1]\t0:Sequential,1:Interleaved"


    # 11. issue MRS "without resetting the DLL"
    issue_ddr2_command 3 0x20000000

    # ADD: AT: 15. OCD Cali
    mww 0xffffe808 [ expr { [read_memory 0xffffe808 32 1] | 7<<12} ]

    echo "-> \[info\] DDRSDRC_CR@0xffffe808: "
    set DDRSDRC_CR [read_memory 0xffffe808 32 1]
    echo "\tNC:[get_bit $DDRSDRC_CR 0 0b11]\t0:9Col,1:10Col,2:11Col,3:12Col"
    echo "\tNR:[get_bit $DDRSDRC_CR 2 0b11]\t0:11Row,1:12Row,2:13Row,3:14Row"
    echo "\tCAS:[get_bit $DDRSDRC_CR 4 0b111]\t"
    echo "\tDLL:[get_bit $DDRSDRC_CR 7 1]\tDLL reset enable/not"
    echo "\tDIC:[get_bit $DDRSDRC_CR 8 1]\tDriver Impedance 0:normal,1:weak"
    echo "\tDIS_DLL:[get_bit $DDRSDRC_CR 9 1]\tDLL 0:enable,1:disable"
    echo "\tOCD:[get_bit $DDRSDRC_CR 12 0b111]\t0:Exit OCD,1:OCD Cali"
    echo "\tNB:[get_bit $DDRSDRC_CR 20 1]\t0:4 Banks,1:8 Banks"
    echo "\tDECOD:[get_bit $DDRSDRC_CR 22 1]\t0:Sequential,1:Interleaved"

    
    # 12.1 issue EMRS1(OCD Cali): A9=1,A8=1,A7=1
    # ADD: AT: BA0=1 "must be issued with other operating parameters of EMRS"
    issue_ddr2_command 5 [ expr { 0x20000000 | 1<<(9+2) | 1<<(8+2) | 1<<(7+2) | 1<<(24)} ]
    echo "###############[mdw [ expr { 0x20000000 | 1<<(9+2) | 1<<(8+2) | 1<<(7+2) | 1<<(24)} ]]"

    # AD: AT: 17. OCD Exit 
    mww 0xffffe808 [ expr { [read_memory 0xffffe808 32 1] &~ (7<<12)} ]

    echo "-> \[info\] DDRSDRC_CR@0xffffe808: "
    set DDRSDRC_CR [read_memory 0xffffe808 32 1]
    echo "\tNC:[get_bit $DDRSDRC_CR 0 0b11]\t0:9Col,1:10Col,2:11Col,3:12Col"
    echo "\tNR:[get_bit $DDRSDRC_CR 2 0b11]\t0:11Row,1:12Row,2:13Row,3:14Row"
    echo "\tCAS:[get_bit $DDRSDRC_CR 4 0b111]\t"
    echo "\tDLL:[get_bit $DDRSDRC_CR 7 1]\tDLL reset enable/not"
    echo "\tDIC:[get_bit $DDRSDRC_CR 8 1]\tDriver Impedance 0:normal,1:weak"
    echo "\tDIS_DLL:[get_bit $DDRSDRC_CR 9 1]\tDLL 0:enable,1:disable"
    echo "\tOCD:[get_bit $DDRSDRC_CR 12 0b111]\t0:Exit OCD,1:OCD Cali"
    echo "\tNB:[get_bit $DDRSDRC_CR 20 1]\t0:4 Banks,1:8 Banks"
    echo "\tDECOD:[get_bit $DDRSDRC_CR 22 1]\t0:Sequential,1:Interleaved"


    # 12.2 issue EMRS1(OCD Exit)
    # ADD: AT: BA0=1
    issue_ddr2_command 5 [ expr { 0x20000000 | 1<<(24) } ]

    # 13. issue Normal mode
    issue_ddr2_command 0 0x20000000

    # ADD: 
    # AT: 20. Perform Write
    mww 0x20000000 0
    # AT: 21. Set Refersh
    mww 0xffffe804 0x03e8 ;#DDRCK@128MHz

    mww 0x20000000 0x12345678
    echo "-> \[info\]DDR2 Test Read: [mdw 0x20000000]"
    ##########################################################

	echo "-> \[info\] board initialization done."
    echo ""
    echo "-> use 'telnet localhost 4444' to connect to REPL over telnet."
    echo "-> use 'board_init' in telnet to re-initialize anytime."

    echo "------------------------------------------------"
    echo ""
}
board_init $_DEBUG


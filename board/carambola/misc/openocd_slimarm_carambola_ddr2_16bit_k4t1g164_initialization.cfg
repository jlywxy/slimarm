########################################










# NOTE: THE FILE IS DEPRECATED










########################################



# DDR2 Initialization
# For AT91SAM CPUs
# For DDR2: Samsung K4T1G164

set DDR_BA0_BIT 24
set DDR_BA1_BIT 25
set ADDRESS_OFFSET 0 ;# ADDR[1]=DDR[0] in 16-bit
set DDR_BASE 0x20000000

proc set_reg_bit { REG POS MASK VALUE } {
    set BIT_CLEARED_DATA [ expr { ( [read_memory $REG 32 1] | ( $MASK << $POS)) &~ ( $MASK << $POS ) } ]
    mww $REG [ expr { $BIT_CLEARED_DATA | ( ( $VALUE & $MASK ) << $POS ) } ]
}

# The Actual Bus Address to Physical Pin mapping is 
# Bus_Address = EBI_Logical_Address
# EBI_Logical_Address[1] = DRAM_Physical_Address[0] 
# EBI_Physical_Address[2] = DRAM_Physical_Address[0]
# EBI_Physical_Address is not significant, only for hardware schematic.
# When trying to write the second Half-Word, toggle EBI_Logical_Address[1].
# The Bank Select lines not shifted. BA0 = EBI_Logical_Address[24],
# BA1 = EBI_Logical_Address[25], BA2 = EBI_Logical_Address[26].

# Writing Word(4-byte) is not for 16-bit bus width
# And will write twice (Half-Word 0 to 1)
    
# Writing Half-Word(2-byte, int) is referenced from 
# Application Note "Implementation of DDR2 on AT91SAM9G45 Devices"
# And will write once per command

proc issue_ddr2_mrs { BURST_LENGTH BURST_TYPE CAS TM DLL WR PD } {
    global DDR_BA0_BIT
    global DDR_BA1_BIT
    global ADDRESS_OFFSET
    global DDR_BASE

    echo "-> \[info\]Issue MRS DDR COMMAND (3)"
    mww 0xffffe800 3
    sleep 1
    # MRS Command: BA0=BA1=0
    mwh [ expr { $DDR_BASE  } ] 0
    sleep 1
    echo "-> \[info\] Mode Reg: [mdw 0xffffe800]"
}
proc issue_ddr2_emrs1 { DLL DIC RTT ADDITIVE_LATENCY RTT2 OCD DQS RDQS QOFF } {
    global DDR_BA0_BIT
    global DDR_BA1_BIT
    global ADDRESS_OFFSET
    global DDR_BASE

    echo "-> \[info\]Issue EMRS1 DDR COMMAND (5)"
    mww 0xffffe800 5
    sleep 1
    # EMRS1 Command: BA0=1
    mwh [ expr { $DDR_BASE | ( 1 << $DDR_BA0_BIT ) } ] 0
    sleep 1
    echo "-> \[info\] Mode Reg: [mdw 0xffffe800]"
}
proc issue_ddr2_emrs2 { PASR DCC SRF } {
    global DDR_BA0_BIT
    global DDR_BA1_BIT
    global ADDRESS_OFFSET
    global DDR_BASE

    echo "-> \[info\]Issue EMRS2 DDR COMMAND"
    mww 0xffffe800 5
    sleep 1
    # EMRS2 Command: BA1=1
    mwh [ expr { $DDR_BASE | ( 1 << $DDR_BA1_BIT ) } ] 0
    sleep 1
    echo "-> \[info\] Mode Reg: [mdw 0xffffe800]"
}
proc issue_ddr2_emrs3 { } {
    global DDR_BA0_BIT
    global DDR_BA1_BIT
    global ADDRESS_OFFSET
    global DDR_BASE

    echo "-> \[info\]Issue EMRS3 DDR COMMAND"
    mww 0xffffe800 5
    sleep 1
    # EMRS3 Command: BA0=BA1=1
    mwh [ expr { $DDR_BASE | ( 1 << $DDR_BA0_BIT | 1 << $DDR_BA1_BIT ) } ] 0
    sleep 1
    echo "-> \[info\] Mode Reg: [mdw 0xffffe800]"
}
proc issue_ddr2_nop { } {
    global DDR_BA0_BIT
    global DDR_BA1_BIT
    global ADDRESS_OFFSET
    global DDR_BASE

    echo "-> \[info\]Issue NOP DDR COMMAND"
    mww 0xffffe800 1
    sleep 1
    mwh $DDR_BASE 0
    sleep 1
    echo "-> \[info\] Mode Reg: [mdw 0xffffe800]"
}
proc issue_ddr2_precharge { } {
    global DDR_BA0_BIT
    global DDR_BA1_BIT
    global ADDRESS_OFFSET
    global DDR_BASE

    echo "-> \[info\]Issue PRECHARGE DDR COMMAND"
    mww 0xffffe800 2
    sleep 1
    mwh $DDR_BASE 0
    sleep 1
    echo "-> \[info\] Mode Reg: [mdw 0xffffe800]"
}
proc issue_ddr2_autofresh { } {
    global DDR_BA0_BIT
    global DDR_BA1_BIT
    global ADDRESS_OFFSET
    global DDR_BASE

    echo "-> \[info\]Issue AUTOFRESH DDR COMMAND"
    mww 0xffffe800 4
    sleep 1
    mwh $DDR_BASE 0
    sleep 1
    echo "-> \[info\] Mode Reg: [mdw 0xffffe800]"
}
proc issue_ddr2_normal { } {
    global DDR_BA0_BIT
    global DDR_BA1_BIT
    global ADDRESS_OFFSET
    global DDR_BASE

    echo "-> \[info\]Issue NORMAL DDR COMMAND"
    mww 0xffffe800 0
    sleep 1
    mwh $DDR_BASE 0
    sleep 1
    echo "-> \[info\] Mode Reg: [mdw 0xffffe800]"
}

proc init_ddr2 { } {
    global DDR_BA0_BIT
    global DDR_BA1_BIT
    global ADDRESS_OFFSET
    global DDR_BASE
    
    ##########################################################
    ####### Setting up DDR2
    
    mww 0xffffe808 [ expr { 1<<0 | 2<<2 |  3<<4 | 1<<20} ]
    mww 0xffffe80c [ expr { 15<<0 | 15<<4 | 15<<8 | 15<<12 | 15<<16 | 15<<20 | 15<<24 | 15<<28 } ]
    mww 0xffffe810 [ expr { 15<<0 | 15<<8 | 200<<16 |  15<<24} ]
    mww 0xffffe814 [ expr { 15<<0 | 15<<4 | 15<<8 | 15<<12 | 15<<16 } ]
    
    echo "-> \[info\] DDRSDRC_CR@0xffffe808: "
    set DDRSDRC_CR [read_memory 0xffffe808 32 1]
    echo "\tNC:[get_bit $DDRSDRC_CR 0 0b11]\t0:9Col,1:10Col,2:11Col,3:12Col"
    echo "\tNR:[get_bit $DDRSDRC_CR 2 0b11]\t0:11Row,1:12Row,2:13Row,3:14Row"
    echo "\tCAS:[get_bit $DDRSDRC_CR 4 0b111]\t"
    echo "\tNB:[get_bit $DDRSDRC_CR 20 1]\t0:4 Banks,1:8 Banks"

    echo "-> \[info\] DDRSDRC_TPR0@0xffffe80c: "
    set DDRSDRC_TPR0 [read_memory 0xffffe80c 32 1]
    echo "\tTRAS: [get_bit $DDRSDRC_TPR0 0 0b1111]"
    echo "\tTRCD: [get_bit $DDRSDRC_TPR0 4 0b1111]"
    echo "\tTWR: [get_bit $DDRSDRC_TPR0 8 0b1111]"
    echo "\tTRC: [get_bit $DDRSDRC_TPR0 12 0b1111]"
    echo "\tTRP: [get_bit $DDRSDRC_TPR0 16 0b1111]"
    echo "\tTRRD: [get_bit $DDRSDRC_TPR0 20 0b1111]"
    echo "\tTWTR: [get_bit $DDRSDRC_TPR0 24 0b111]"
    echo "\tREDUCE_WRRD: [get_bit $DDRSDRC_TPR0 27 1]"
    echo "\tTMRD: [get_bit $DDRSDRC_TPR0 28 0b1111]"

    echo "-> \[info\] DDRSDRC_TPR1@0xffffe810: "
    set DDRSDRC_TPR1 [read_memory 0xffffe810 32 1]
    echo "\tTRFC: [get_bit $DDRSDRC_TPR1 0 0b11111]"
    echo "\tTXSNR: [get_bit $DDRSDRC_TPR1 8 0b11111111]"
    echo "\tTXSRD: [get_bit $DDRSDRC_TPR1 16 0b11111111]"
    echo "\tTXP: [get_bit $DDRSDRC_TPR1 24 0b1111]"

    echo "-> \[info\] DDRSDRC_TPR2@0xffffe814: "
    set DDRSDRC_TPR2 [read_memory 0xffffe814 32 1]
    echo "\tTXARD: [get_bit $DDRSDRC_TPR2 0 0b1111]"
    echo "\tTXARDS: [get_bit $DDRSDRC_TPR2 4 0b1111]"
    echo "\tTRPA: [get_bit $DDRSDRC_TPR2 8 0b1111]"
    echo "\tTRTP: [get_bit $DDRSDRC_TPR2 12 0b111]"
    echo "\tTFAW: [get_bit $DDRSDRC_TPR2 16 0b1111]"

    mww 0xfffffc04 0x0
    set_reg_bit 0xfffffc00 2 1 1
    echo "-> \[info\] PMC_SCSR@0xfffffc08: "
    set PMC_SCSR [read_memory 0xfffffc08 32 1]
    echo "\tDDRCK:[get_bit $PMC_SCSR 2 1]"

    ##########################################################
#     ####### Init DDR2
    issue_ddr2_nop
    issue_ddr2_nop
    issue_ddr2_precharge
    #                   PASR DCC SRF
    issue_ddr2_emrs2    0    0   0
    #                   
    issue_ddr2_emrs3
    #                   DLL DIC RTT ADDITIVE_LATENCY RTT2 OCD DQS RDQS QOFF
    issue_ddr2_emrs1    0   0   1   0                1    0   1   0    0
    # AT enable DLL reset
    set_reg_bit 0xffffe808 7 1 1
    #                   BURST_LENGTH BURST_TYPE CAS    TM DLL WR PD
    issue_ddr2_mrs      0b011        0          0b011  0  1   1  0
    issue_ddr2_precharge
    issue_ddr2_autofresh
    issue_ddr2_autofresh
    # AT disable DLL reset
    set_reg_bit 0xffffe808 7 1 0
    #                   BURST_LENGTH BURST_TYPE CAS    TM DLL WR PD
    issue_ddr2_mrs      0b011        0          0b011  0  0   1  0
    # AT OCD
    set_reg_bit 0xffffe808 12 0b111 7
    #                   DLL DIC RTT ADDITIVE_LATENCY RTT2 OCD   DQS RDQS QOFF
    issue_ddr2_emrs1    0   0   1   0                1    0b111 1   0    1
    # AT OCD exit
    set_reg_bit 0xffffe808 12 0b111 0
    #                   DLL DIC RTT ADDITIVE_LATENCY RTT2 OCD DQS RDQS QOFF
    issue_ddr2_emrs1    0   0   1   0                1    0   1   0    1
    issue_ddr2_normal
    mww 0x20000000 0
    mww 0xffffe804 0x40f
    echo "\n"
    mww 0x20000000 0x12345678
    echo "-> \[info\] DDR2 Test Read: [mdw 0x20000000]"
    ##########################################################
}